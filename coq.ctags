# TODO:
# - all table should jump to comment
# - all table must have /./
#
# TODO: {pcre2} by default? https://github.com/universal-ctags/ctags/issues/3181
#
# NOTE: end of sentence can be eof. this shouldn't be problem for files with newline at eof
#
# NOTE(word boundary): \b at the beginning of the pattern since we're always at
# the start of string. So instead, eat any non-keyword word, so that the start
# position is always at the start of a word.
#
# NOTE unicode identifier: https://github.com/rouge-ruby/rouge/pull/1764
# TODO: this doesn't work! Example `Inductive εμπτγ :=.`

--langdef=Coq
--map-Coq=+.v

--kinddef-Coq=d,definition,IsDefinition
--kinddef-Coq=a,assumption,IsAssumption
--kinddef-Coq=t,theorem,IsProof
--kinddef-Coq=i,inductive,Inductive
--kinddef-Coq=c,constructor,Constructor
--kinddef-Coq=r,record,Record/Class
--kinddef-Coq=f,field,Field
--kinddef-Coq=l,ltac,Ltac

--_tabledef-Coq=main
--_tabledef-Coq=definition
--_tabledef-Coq=fixpoint
--_tabledef-Coq=instance
--_tabledef-Coq=theorem
--_tabledef-Coq=inductive
--_tabledef-Coq=ltac

#
# Comment
#
--_tabledef-Coq=comment
# allow nested comment
--_mtable-regex-Coq=comment/\(\*//{tenter=comment}
--_mtable-regex-Coq=comment/\*\)//{tleave}
--_mtable-regex-Coq=comment/.//

--_tabledef-Coq=skipComment
--_mtable-regex-Coq=skipComment/\(\*//{tenter=comment}

#
# Utils
#
# TODO: string https://coq.inria.fr/refman/language/core/basic.html#grammar-token-string
# TODO: attributes? https://coq.inria.fr/refman/language/core/basic.html#grammar-token-attributes Used for record fields
--_tabledef-Coq=skipWhiteSpace
--_tabledef-Coq=skip

--_mtable-regex-Coq=skipWhiteSpace/\s+//{pcre2}

--_mtable-extend-Coq=skip+skipWhiteSpace
--_mtable-extend-Coq=skip+skipComment

--_tabledef-Coq=skipToNextSentence
--_mtable-regex-Coq=skipToNextSentence/\.[[:space:]]//{tleave}
--_mtable-regex-Coq=skipToNextSentence/.//

#
# Term and Binder
#
--_tabledef-Coq=paren
--_tabledef-Coq=brace
--_tabledef-Coq=bracket
# NOTE to disambiguate `with` of term `match` and vernac
--_tabledef-Coq=match
# https://coq.inria.fr/refman/language/core/assumptions.html#grammar-token-binder
--_tabledef-Coq=skipEnclosed
--_tabledef-Coq=skipTerm

# NOTE: assumes that parens/braces/brackets in terms are well-matched
--_mtable-regex-Coq=skipEnclosed/\(//{pcre2}{tenter=paren}
--_mtable-regex-Coq=skipEnclosed/\{//{pcre2}{tenter=brace}
--_mtable-regex-Coq=skipEnclosed/\[//{pcre2}{tenter=bracket}

--_mtable-extend-Coq=paren+skipComment
--_mtable-extend-Coq=paren+skipEnclosed
--_mtable-regex-Coq=paren/\)//{tleave}
--_mtable-regex-Coq=paren/match\b//{pcre2}{tenter=match}
--_mtable-regex-Coq=paren/\w+//{pcre2}
--_mtable-regex-Coq=paren/.//

--_mtable-extend-Coq=brace+skipComment
--_mtable-extend-Coq=brace+skipEnclosed
--_mtable-regex-Coq=brace/\}//{tleave}
--_mtable-regex-Coq=brace/match\b//{pcre2}{tenter=match}
--_mtable-regex-Coq=brace/\w+//{pcre2}
--_mtable-regex-Coq=brace/.//

--_mtable-extend-Coq=bracket+skipComment
--_mtable-extend-Coq=bracket+skipEnclosed
--_mtable-regex-Coq=bracket/\]//{tleave}
--_mtable-regex-Coq=bracket/match\b//{pcre2}{tenter=match}
--_mtable-regex-Coq=bracket/\w+//{pcre2}
--_mtable-regex-Coq=bracket/.//

--_mtable-extend-Coq=match+skipComment
--_mtable-extend-Coq=bracket+skipEnclosed
--_mtable-regex-Coq=match/end\b//{pcre2}{tleave}
--_mtable-regex-Coq=match/match\b//{pcre2}{tenter=match}
--_mtable-regex-Coq=match/\w+//{pcre2}
--_mtable-regex-Coq=match/.//

--_mtable-extend-Coq=skipTerm+skipEnclosed
# NOTE: see word boundary note
--_mtable-regex-Coq=skipTerm/match\b//{pcre2}{tenter=match}

# --_mtable-regex-Coq=skipName/(?:\p{L}|_)(?:\p{L}|\p{N}|_|')*//


#
# Main
#
--_mtable-extend-Coq=main+skipComment
--_mtable-regex-Coq=main/(?:Definition|Example)\b//{pcre2}{tenter=definition}
--_mtable-regex-Coq=main/(?:Fixpoint|CoFixpoint)\b//{pcre2}{tenter=fixpoint}
--_mtable-regex-Coq=main/Existing\s+Instances?\b//{pcre2}{tenter=skipToNextSentence}
--_mtable-regex-Coq=main/Instance\b//{pcre2}{tenter=instance}
--_mtable-regex-Coq=main/(?:Theorem|Lemma|Fact|Remark|Corollary|Proposition|Property)\b//{pcre2}{tenter=theorem}
--_mtable-regex-Coq=main/(?:Inductive|CoInductive|Variant)\b//{pcre2}{tenter=inductive}
--_mtable-regex-Coq=main/Ltac\b//{pcre2}{tenter=ltac}
--_mtable-regex-Coq=main/\w+//{pcre2}
--_mtable-regex-Coq=main/.//


# Definition https://coq.inria.fr/refman/language/core/definitions.html#coq:cmd.Definition
--_mtable-extend-Coq=definition+skip
--_mtable-regex-Coq=definition/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/d/{pcre2}{tjump=skipToNextSentence}
--_mtable-regex-Coq=definition/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/d/{pcre2}{tjump=skipToNextSentence}


# Fixpoint https://coq.inria.fr/refman/language/core/inductive.html#coq:cmd.Fixpoint
# TODO: with
--_mtable-extend-Coq=fixpoint+skip
--_mtable-regex-Coq=fixpoint/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/d/{pcre2}{tjump=skipToNextSentence}

# Instance https://coq.inria.fr/refman/addendum/type-classes.html#coq:cmd.Instance
--_mtable-extend-Coq=instance+skip
--_mtable-regex-Coq=instance/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/d/{pcre2}{tjump=skipToNextSentence}
# anonymouse instance
--_mtable-regex-Coq=instance/.//{pcre2}{tjump=skipToNextSentence}


# Theorem https://coq.inria.fr/refman/language/core/definitions.html#coq:cmd.Theorem
# TODO: with
--_mtable-extend-Coq=theorem+skip
--_mtable-regex-Coq=theorem/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/t/{pcre2}{tjump=skipToNextSentence}


# Inductive https://coq.inria.fr/refman/language/core/inductive.html#coq:cmd.Inductive
# TODO: constructors_or_record
--_tabledef-Coq=skipToConstructors
--_tabledef-Coq=constructor
--_tabledef-Coq=skipConstructorRest
--_mtable-extend-Coq=inductive+skip
--_mtable-regex-Coq=inductive/>//
--_mtable-regex-Coq=inductive/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/i/{pcre2}{tjump=skipToConstructors}

# skip terms until :=
--_mtable-extend-Coq=skipToConstructors+skip
--_mtable-extend-Coq=skipToConstructors+skipEnclosed
--_mtable-regex-Coq=skipToConstructors/:=//{pcre2}{tjump=constructor}
# := can be missing
--_mtable-regex-Coq=skipToConstructors/\.\s//{pcre2}{tleave}
--_mtable-regex-Coq=skipToConstructors/.//{pcre2}

--_mtable-extend-Coq=constructor+skip
--_mtable-regex-Coq=constructor/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/c/{pcre2}{tjump=skipConstructorRest}
# skip the optional initial `|`
--_mtable-regex-Coq=constructor/\|//{pcre2}
# no constructor
--_mtable-regex-Coq=constructor/\.\s//{pcre2}{tleave}
--_mtable-regex-Coq=constructor/.//

--_mtable-extend-Coq=skipConstructorRest+skipTerm
# next constructor
--_mtable-regex-Coq=skipConstructorRest/\|//{pcre2}{tjump=constructor}
# end of Inductive
--_mtable-regex-Coq=skipConstructorRest/\.[[:space:]]//{tleave}
# mutually recursive
--_mtable-regex-Coq=skipConstructorRest/with\b//{pcre2}{tjump=inductive}
--_mtable-regex-Coq=skipConstructorRest/\w+//{pcre2}
--_mtable-regex-Coq=skipConstructorRest/.//

# TODO: canonical structure (only the form with :=)
# --_mtable-regex-Coq=main/(Record|Structure|Class)[[:space:]>]+((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\2/r/{pcre2}
# TODO: singleton_class_definition  https://coq.inria.fr/refman/addendum/type-classes.html#coq:cmd.Class
# TODO record: constructor: Build_\n
# --_tabledef-Coq=record
# --_tabledef-Coq=record_constructor
# --_tabledef-Coq=fields
# --_mtable-extend-Coq=record+skip
# --_mtable-regex-Coq=main/(Record|Structure|Class)[[:space:]>]+((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\2/r/{pcre2}{tenter=record}
# --_mtable-regex-Coq=record/\(\*//{tenter=comment}
# # skip terms until :=
# --_mtable-regex-Coq=record/\(//{tenter=paren}
# --_mtable-regex-Coq=record/\{//{tenter=brace}
# --_mtable-regex-Coq=record/\[//{tenter=bracket}
# --_mtable-regex-Coq=record/:=//{tjump=record_constructor}
# # := can be missing
# --_mtable-regex-Coq=record/\.[[:space:]]//{tleave}
# # explicit constructor
# --_mtable-regex-Coq=record_constructor/:=[[:space:]]*((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)[[:space:]]*\{//{pcre2}{tjump=fields}
# # TODO: implicit constructor must use optscript to get the record name https://github.com/universal-ctags/ctags/commit/bd186360d320c31e9777827dbdda155fdc5641bf
# --_mtable-regex-Coq=record_constructor/:=[[:space:]]*\{//{tjump=fields}
# --_mtable-regex-Coq=record/.//
# # TODO `with`
# # TODO: this generates a lot of weird stuff.. should match braces...
# # --_mtable-regex-Coq=record/[{;][[:space:]]*((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)[^:]*:/\1/f/{pcre2}
# --_mtable-regex-Coq=record/}[[:space:]]*\.//{tleave}
# --_mtable-regex-Coq=record/.//

# Ltac https://coq.inria.fr/refman/proof-engine/ltac.html#coq:cmd.Ltac
--_mtable-extend-Coq=ltac+skip
--_mtable-regex-Coq=ltac/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/l/{pcre2}{tjump=skipToNextSentence}


# vim:set ft=conf:
