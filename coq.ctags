# TODO:
# - all table should jump to comment
# - all table must have /./
#
# TODO: {pcre2} by default? https://github.com/universal-ctags/ctags/issues/3181
#
# NOTE: end of sentence can be eof. this shouldn't be problem for files with newline at eof
#
# NOTE(word boundary): \b at the beginning of the pattern since we're always at
# the start of string. So instead, eat any non-keyword word, so that the start
# position is always at the start of a word.
#
# NOTE unicode identifier: ((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*) https://github.com/rouge-ruby/rouge/pull/1764
# TODO: this doesn't work! Example: `Inductive εμπτγ :=.` ⇒ [ILLEGAL BYTE in line XXX]. Bug?
# Use `([^@|({[`:[:space:]]+)` ?

--langdef=Coq
--map-Coq=+.v

--kinddef-Coq=d,definition,IsDefinition
--kinddef-Coq=a,assumption,IsAssumption
--kinddef-Coq=t,theorem,IsProof
--kinddef-Coq=i,inductive,Inductive
--kinddef-Coq=c,constructor,Constructor
--kinddef-Coq=r,record,Record/Class
--kinddef-Coq=f,field,Field
--kinddef-Coq=l,ltac,Ltac

--_tabledef-Coq=main
--_tabledef-Coq=definition
--_tabledef-Coq=fixpoint
--_tabledef-Coq=instance
--_tabledef-Coq=theorem
--_tabledef-Coq=inductive
--_tabledef-Coq=record
--_tabledef-Coq=ltac

#
# Comment
#
--_tabledef-Coq=comment
# allow nested comment
--_mtable-regex-Coq=comment/\(\*//{tenter=comment}
--_mtable-regex-Coq=comment/\*\)//{tleave}
--_mtable-regex-Coq=comment/.//

--_tabledef-Coq=skipComment
--_mtable-regex-Coq=skipComment/\(\*//{tenter=comment}

#
# Utils
#
# TODO: string https://coq.inria.fr/refman/language/core/basic.html#grammar-token-string
# TODO: attributes? https://coq.inria.fr/refman/language/core/basic.html#grammar-token-attributes Used for record fields
--_tabledef-Coq=skipWhiteSpace
--_tabledef-Coq=skip

--_mtable-regex-Coq=skipWhiteSpace/\s+//{pcre2}

--_mtable-extend-Coq=skip+skipWhiteSpace
--_mtable-extend-Coq=skip+skipComment

--_tabledef-Coq=skipToNextSentence
--_mtable-regex-Coq=skipToNextSentence/\.\s//{pcre2}{tleave}
--_mtable-regex-Coq=skipToNextSentence/.//

#
# Term and Binder
#
--_tabledef-Coq=paren
--_tabledef-Coq=brace
--_tabledef-Coq=bracket
# NOTE to disambiguate `with` of term `match` and vernac
--_tabledef-Coq=match
# https://coq.inria.fr/refman/language/core/assumptions.html#grammar-token-binder
--_tabledef-Coq=skipEnclosed
--_tabledef-Coq=skipTerm

# NOTE: assumes that parens/braces/brackets in terms are well-matched
--_mtable-regex-Coq=skipEnclosed/\(//{pcre2}{tenter=paren}
--_mtable-regex-Coq=skipEnclosed/\{//{pcre2}{tenter=brace}
--_mtable-regex-Coq=skipEnclosed/\[//{pcre2}{tenter=bracket}

--_mtable-extend-Coq=paren+skipComment
--_mtable-extend-Coq=paren+skipEnclosed
--_mtable-regex-Coq=paren/\)//{tleave}
--_mtable-regex-Coq=paren/match\b//{pcre2}{tenter=match}
--_mtable-regex-Coq=paren/\w+//{pcre2}
--_mtable-regex-Coq=paren/.//

--_mtable-extend-Coq=brace+skipComment
--_mtable-extend-Coq=brace+skipEnclosed
--_mtable-regex-Coq=brace/\}//{tleave}
--_mtable-regex-Coq=brace/match\b//{pcre2}{tenter=match}
--_mtable-regex-Coq=brace/\w+//{pcre2}
--_mtable-regex-Coq=brace/.//

--_mtable-extend-Coq=bracket+skipComment
--_mtable-extend-Coq=bracket+skipEnclosed
--_mtable-regex-Coq=bracket/\]//{tleave}
--_mtable-regex-Coq=bracket/match\b//{pcre2}{tenter=match}
--_mtable-regex-Coq=bracket/\w+//{pcre2}
--_mtable-regex-Coq=bracket/.//

--_mtable-extend-Coq=match+skipComment
--_mtable-extend-Coq=bracket+skipEnclosed
--_mtable-regex-Coq=match/end\b//{pcre2}{tleave}
--_mtable-regex-Coq=match/match\b//{pcre2}{tenter=match}
--_mtable-regex-Coq=match/\w+//{pcre2}
--_mtable-regex-Coq=match/.//

--_mtable-extend-Coq=skipTerm+skipEnclosed
# NOTE: see word boundary note
--_mtable-regex-Coq=skipTerm/match\b//{pcre2}{tenter=match}


#
# Main
#
--_mtable-extend-Coq=main+skipComment
--_mtable-regex-Coq=main/(?:Definition|Example)\b//{pcre2}{tenter=definition}
--_mtable-regex-Coq=main/(?:Fixpoint|CoFixpoint)\b//{pcre2}{tenter=fixpoint}
--_mtable-regex-Coq=main/Existing\s+Instances?\b//{pcre2}{tenter=skipToNextSentence}
--_mtable-regex-Coq=main/Instance\b//{pcre2}{tenter=instance}
--_mtable-regex-Coq=main/(?:Theorem|Lemma|Fact|Remark|Corollary|Proposition|Property)\b//{pcre2}{tenter=theorem}
--_mtable-regex-Coq=main/(?:Inductive|CoInductive|Variant)\b//{pcre2}{tenter=inductive}
# TODO: canonical structure (only the form with :=) https://coq.inria.fr/refman/language/extensions/canonical.html#coq:cmd.Canonical-Structure
--_mtable-regex-Coq=main/Canonical\s+Structure\b//{pcre2}{tenter=skipToNextSentence}
--_mtable-regex-Coq=main/(?:Record|Structure|Class)\b//{pcre2}{tenter=record}
--_mtable-regex-Coq=main/Ltac\b//{pcre2}{tenter=ltac}
--_mtable-regex-Coq=main/\w+//{pcre2}
--_mtable-regex-Coq=main/.//


# Definition https://coq.inria.fr/refman/language/core/definitions.html#coq:cmd.Definition
--_mtable-extend-Coq=definition+skip
--_mtable-regex-Coq=definition/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/d/{pcre2}{tjump=skipToNextSentence}


# Fixpoint https://coq.inria.fr/refman/language/core/inductive.html#coq:cmd.Fixpoint
# TODO: with
--_mtable-extend-Coq=fixpoint+skip
--_mtable-regex-Coq=fixpoint/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/d/{pcre2}{tjump=skipToNextSentence}

# Instance https://coq.inria.fr/refman/addendum/type-classes.html#coq:cmd.Instance
--_mtable-extend-Coq=instance+skip
--_mtable-regex-Coq=instance/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/d/{pcre2}{tjump=skipToNextSentence}
# anonymouse instance
--_mtable-regex-Coq=instance/.//{pcre2}{tjump=skipToNextSentence}


# Theorem https://coq.inria.fr/refman/language/core/definitions.html#coq:cmd.Theorem
# TODO: with
--_mtable-extend-Coq=theorem+skip
--_mtable-regex-Coq=theorem/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/t/{pcre2}{tjump=skipToNextSentence}


# Inductive https://coq.inria.fr/refman/language/core/inductive.html#coq:cmd.Inductive
# TODO: constructors_or_record
--_tabledef-Coq=skipToConstructors
--_tabledef-Coq=constructor
--_tabledef-Coq=skipConstructorRest

--_mtable-extend-Coq=inductive+skip
--_mtable-regex-Coq=inductive/>//
--_mtable-regex-Coq=inductive/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/i/{pcre2}{tjump=skipToConstructors}

# skip binders/terms until :=
--_mtable-extend-Coq=skipToConstructors+skip
--_mtable-extend-Coq=skipToConstructors+skipTerm
--_mtable-regex-Coq=skipToConstructors/:=//{pcre2}{tjump=constructor}
# := can be missing
--_mtable-regex-Coq=skipToConstructors/\.\s//{pcre2}{tleave}
--_mtable-regex-Coq=skipToConstructors/.//{pcre2}

--_mtable-extend-Coq=constructor+skip
--_mtable-regex-Coq=constructor/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/c/{pcre2}{tjump=skipConstructorRest}
# skip the optional initial `|`
--_mtable-regex-Coq=constructor/\|//{pcre2}
# no constructor
--_mtable-regex-Coq=constructor/\.\s//{pcre2}{tleave}
--_mtable-regex-Coq=constructor/.//

--_mtable-extend-Coq=skipConstructorRest+skipTerm
# next constructor
--_mtable-regex-Coq=skipConstructorRest/\|//{pcre2}{tjump=constructor}
# end of Inductive
--_mtable-regex-Coq=skipConstructorRest/\.\s//{pcre2}{tleave}
# mutually recursive
--_mtable-regex-Coq=skipConstructorRest/with\b//{pcre2}{tjump=inductive}
--_mtable-regex-Coq=skipConstructorRest/\w+//{pcre2}
--_mtable-regex-Coq=skipConstructorRest/.//


# Record https://coq.inria.fr/refman/language/core/records.html#coq:cmd.Record
# TODO: singleton_class_definition  https://coq.inria.fr/refman/addendum/type-classes.html#coq:cmd.Class
# TODO `with`
--_tabledef-Coq=skipToRecordConstructor
--_tabledef-Coq=recordConstructor
--_tabledef-Coq=recordField
--_tabledef-Coq=skipRecordFieldRest

--_mtable-extend-Coq=record+skip
--_mtable-regex-Coq=record/>//
--_mtable-regex-Coq=record/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/r/{pcre2}{tjump=skipToRecordConstructor}

# skip binders/terms until :=
--_mtable-extend-Coq=skipToRecordConstructor+skip
--_mtable-extend-Coq=skipToRecordConstructor+skipEnclosed
--_mtable-regex-Coq=skipToRecordConstructor/:=//{pcre2}{tjump=recordConstructor}
# := can be missing
--_mtable-regex-Coq=skipToRecordConstructor/\.\s//{pcre2}{tleave}
--_mtable-regex-Coq=skipToRecordConstructor/.//{pcre2}

--_mtable-extend-Coq=recordConstructor+skip
# explicit constructor
--_mtable-regex-Coq=recordConstructor/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)\s*\{/\1/c/{pcre2}{tjump=recordField}
# TODO: implicit constructor must use optscript to get the record name https://github.com/universal-ctags/ctags/commit/bd186360d320c31e9777827dbdda155fdc5641bf
--_mtable-regex-Coq=recordConstructor/\{//{pcre2}{tjump=recordField}

--_mtable-extend-Coq=recordField+skip
# skip attributes
--_mtable-extend-Coq=recordField+skipEnclosed
--_mtable-regex-Coq=recordField/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/f/{pcre2}{tjump=skipRecordFieldRest}
# no field
--_mtable-regex-Coq=recordField/\}\.\s//{pcre2}{tleave}
--_mtable-regex-Coq=recordField/.//

--_mtable-extend-Coq=skipRecordFieldRest+skip
--_mtable-extend-Coq=skipRecordFieldRest+skipEnclosed
# next field
--_mtable-regex-Coq=skipRecordFieldRest/;//{pcre2}{tjump=recordField}
# end of record
--_mtable-regex-Coq=skipRecordFieldRest/\}\.\s//{pcre2}{tleave}
--_mtable-regex-Coq=skipRecordFieldRest/.//{pcre2}


# Ltac https://coq.inria.fr/refman/proof-engine/ltac.html#coq:cmd.Ltac
--_mtable-extend-Coq=ltac+skip
--_mtable-regex-Coq=ltac/((?:\p{L}|_)(?:\p{L}|\p{N}|_|')*)/\1/l/{pcre2}{tjump=skipToNextSentence}


# vim:set ft=conf:
